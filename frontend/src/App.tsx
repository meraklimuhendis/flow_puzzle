import React from 'react';
import { createSampleGrid } from './utils/gridUtils';
import { Position, Cell, CellType } from './types/game';

function App() {
  const [apiStatus, setApiStatus] = React.useState('Checking...');
  const [grid, setGrid] = React.useState(() => createSampleGrid());
  const [isDrawing, setIsDrawing] = React.useState(false);
  const [currentPath, setCurrentPath] = React.useState<Position[]>([]);
  const [currentColor, setCurrentColor] = React.useState<string | null>(null);
  const [currentLetter, setCurrentLetter] = React.useState<string | null>(null);
  
  // Ref'ler ile ger√ßek zamanlƒ± deƒüerleri takip edelim
  const currentPathRef = React.useRef<Position[]>([]);
  const isDrawingRef = React.useRef(false);
  const currentColorRef = React.useRef<string | null>(null);
  
  // Mouse durumu i√ßin ek state
  const [isMouseDown, setIsMouseDown] = React.useState(false);
  const isMouseDownRef = React.useRef(false);

  // Visual path tracking (grid'i deƒüi≈ütirmeden)
  const [visualPath, setVisualPath] = React.useState<Position[]>([]);
  const visualPathRef = React.useRef<Position[]>([]);

  // Debug i√ßin currentPath deƒüi≈üimini izleyelim
  React.useEffect(() => {
    console.log('üìç CurrentPath deƒüi≈üti:', currentPath);
  }, [currentPath]);

  React.useEffect(() => {
    const testApi = async () => {
      try {
        const response = await fetch('/api/test');
        const data = await response.json();
        setApiStatus('‚úÖ API Connected: ' + data.message);
      } catch (error) {
        console.error('API Error:', error);
        setApiStatus('‚ùå API Failed');
      }
    };
    
    testApi();
  }, []);

  const handleMouseDown = (position: Position, cell: Cell) => {
    console.log('ÔøΩÔ∏è Mouse down:', position, cell.type, cell.letter);
    
    setIsMouseDown(true);
    isMouseDownRef.current = true;
    
    // Eƒüer letter cell'e mouse down yapƒ±ldƒ±ysa path ba≈ülat
    if (cell.type === CellType.LETTER && cell.letter) {
      startPath(position, cell);
    }
  };

  const handleMouseUp = (position: Position, cell: Cell) => {
    console.log('üñ±Ô∏è Mouse up:', position, cell.type, cell.letter);
    
    setIsMouseDown(false);
    isMouseDownRef.current = false;
    
    // Eƒüer √ßizim yapƒ±yorsak ve aynƒ± renkteki letter'a mouse up yapƒ±ldƒ±ysa path bitir
    if (isDrawing && cell.type === CellType.LETTER && cell.letter === currentLetter && cell.color === currentColor) {
      finishPath(position, cell);
    } else if (isDrawing) {
      // Ba≈üka yerde mouse up yapƒ±ldƒ±ysa √ßizimi durdur
      stopDrawing();
    }
  };

  const handleCellClick = (position: Position, cell: Cell) => {
    console.log('üî• Cell clicked:', JSON.stringify(position), JSON.stringify(cell), 'Type:', cell.type, 'Letter:', cell.letter);
    
    // Click eventi artƒ±k sadece fallback, asƒ±l logic mouse down/up'ta
    if (!isMouseDown && cell.type === CellType.LETTER && cell.letter) {
      console.log('‚úÖ Starting path for letter (click fallback):', cell.letter);
      startPath(position, cell);
    }
  };

  const handleCellHover = (position: Position, cell: Cell) => {
    // SADECE mouse basƒ±lƒ± tutulduƒüunda ve √ßizim yapƒ±yorsak hover ile path devam ettir
    if (isMouseDownRef.current && isDrawingRef.current && cell.type === CellType.EMPTY) {
      const positionExists = currentPathRef.current.some((p: Position) => p.x === position.x && p.y === position.y);
      if (!positionExists) {
        addToPath(position, cell);
      }
    }
  };

  const startPath = (position: Position, cell: Cell) => {
    console.log('üé® Path ba≈ülatƒ±lƒ±yor:', cell.letter, cell.color);
    
    // √ñnceki visual path'i DOM'dan temizle
    clearVisualPathFromDOM();
    
    // State'leri g√ºncelle
    setIsDrawing(true);
    setCurrentPath([position]);
    setCurrentColor(cell.color || null);
    setCurrentLetter(cell.letter || null);
    
    // Ref'leri de g√ºncelle (ger√ßek zamanlƒ± kullanƒ±m i√ßin)
    isDrawingRef.current = true;
    currentPathRef.current = [position];
    currentColorRef.current = cell.color || null;
    
    // Visual path'i temizle ve start position'ƒ± ekle
    setVisualPath([]);
    visualPathRef.current = [];
  };

  // DOM manip√ºlasyonu ile ger√ßek zamanlƒ± visual feedback
  const addVisualPathToDOM = (position: Position) => {
    const selector = `div[data-position="${position.x},${position.y}"]`;
    const element = document.querySelector(selector) as HTMLDivElement;
    
    if (element) {
      // HEMEN DOM'a style ekle
      element.style.backgroundColor = currentColorRef.current || '#4CAF50';
      element.style.border = `3px solid ${currentColorRef.current || '#4CAF50'}`;
      element.style.opacity = '0.8';
      element.style.transform = 'scale(1.1)';
      element.textContent = '‚óè';
      console.log('üöÄ DOM g√ºncellendi:', position.x, position.y, 'selector:', selector);
    } else {
      console.log('‚ùå DOM element bulunamadƒ±:', selector);
    }
  };

  const clearVisualPathFromDOM = () => {
    // T√ºm visual path'leri DOM'dan temizle
    visualPathRef.current.forEach((pos: Position) => {
      const selector = `div[data-position="${pos.x},${pos.y}"]`;
      const element = document.querySelector(selector) as HTMLDivElement;
      if (element) {
        element.style.backgroundColor = '';
        element.style.border = '';
        element.style.opacity = '';
        element.style.transform = '';
        element.textContent = '';
        console.log('üßπ DOM temizlendi:', pos.x, pos.y);
      }
    });
  };

  const addToVisualPath = (position: Position) => {
    console.log('üëÄ addToVisualPath √ßaƒürƒ±ldƒ±:', position);
    
    const currentVisualPath = visualPathRef.current;
    
    // Eƒüer position zaten visual path'de varsa ekleme
    const positionExists = currentVisualPath.some((p: Position) => p.x === position.x && p.y === position.y);
    if (positionExists) {
      console.log('‚ùå Visual pathde zaten var:', position);
      return;
    }

    const newVisualPath = [...currentVisualPath, position];
    
    // State'i g√ºncelle (ama buna g√ºvenme)
    setVisualPath(newVisualPath);
    visualPathRef.current = newVisualPath;
    
    // HEMEN DOM'u g√ºncelle
    console.log('üöÄ DOM g√ºncelleme √ßaƒürƒ±lƒ±yor:', position);
    addVisualPathToDOM(position);
    
    console.log('üëÄ Visual path g√ºncellendi (DOM):', newVisualPath);
  };

  const addToPath = (position: Position, cell: Cell) => {
    console.log('üîç addToPath √ßaƒürƒ±ldƒ±:', position, 'currentPath:', currentPathRef.current);
    
    // Ref'ten g√ºncel path'i al
    const currentPathFromRef = currentPathRef.current;
    
    // Eƒüer position zaten path'de varsa ekleme
    const positionExists = currentPathFromRef.some((p: Position) => p.x === position.x && p.y === position.y);
    if (positionExists) {
      console.log('‚ùå Position zaten var:', position);
      return;
    }

    // Son position ile adjacent mi kontrol et
    if (currentPathFromRef.length === 0) {
      console.log('‚ùå Path bo≈ü');
      return;
    }
    const lastPosition = currentPathFromRef[currentPathFromRef.length - 1];
    const isAdjacent = Math.abs(lastPosition.x - position.x) + Math.abs(lastPosition.y - position.y) === 1;
    
    if (isAdjacent) {
      console.log('‚úÖ Adjacent position, path geni≈ületiliyor');
      const newPath = [...currentPathFromRef, position];
      
      // Hem state'i hem ref'i g√ºncelle
      setCurrentPath(newPath);
      currentPathRef.current = newPath;
      
      // Visual path'i HEMEN g√ºncelle (grid'den baƒüƒ±msƒ±z)
      console.log('üé® addToVisualPath √ßaƒürƒ±lƒ±yor:', position);
      addToVisualPath(position);
      
      // Grid'i de g√ºncelle (ama visual feedback visual path'ten gelecek)
      updateGridWithPath(newPath);
      console.log('Path geni≈ületildi:', newPath);
    } else {
      console.log('‚ùå Position adjacent deƒüil. Last:', lastPosition, 'New:', position);
    }
  };

  const finishPath = (position: Position, cell: Cell) => {
    console.log('Path tamamlandƒ±:', currentLetter, currentPathRef.current.length + 1, 'adƒ±m');
    
    // Final path'i olu≈ütur
    const finalPath = [...currentPathRef.current, position];
    
    // Grid'i son path ile g√ºncelle
    updateGridWithPath(finalPath, true);
    
    // Path state'ini temizle
    setIsDrawing(false);
    setCurrentPath([]);
    setCurrentColor(null);
    setCurrentLetter(null);
    setIsMouseDown(false);
    
    // Ref'leri temizle
    isDrawingRef.current = false;
    currentPathRef.current = [];
    currentColorRef.current = null;
    isMouseDownRef.current = false;
    
    // Visual path'i temizle
    setVisualPath([]);
    visualPathRef.current = [];
  };

  const stopDrawing = () => {
    console.log('√áizim durduruldu');
    
    // DOM'dan visual path'i temizle
    clearVisualPathFromDOM();
    
    // Mevcut path'i temizle
    clearCurrentPath();
    
    setIsDrawing(false);
    setCurrentPath([]);
    setCurrentColor(null);
    setCurrentLetter(null);
    setIsMouseDown(false);
    
    // Ref'leri temizle
    isDrawingRef.current = false;
    currentPathRef.current = [];
    currentColorRef.current = null;
    isMouseDownRef.current = false;
    
    // Visual path'i temizle
    setVisualPath([]);
    visualPathRef.current = [];
  };

  const updateGridWithPath = (path: Position[], isComplete = false) => {
    console.log('üîÑ Updating grid with path:', path, 'isComplete:', isComplete);
    const newGrid = { ...grid };
    newGrid.cells = grid.cells.map((row: Cell[]) => [...row]);
    
    // √ñnceki ge√ßici path'leri temizle (complete olmayan)
    for (let y = 0; y < newGrid.dimensions.height; y++) {
      for (let x = 0; x < newGrid.dimensions.width; x++) {
        const cell = newGrid.cells[y][x];
        if (cell.type === CellType.PATH && !cell.isConnected) {
          console.log('üßπ Clearing old path at:', x, y);
          newGrid.cells[y][x] = {
            ...cell,
            type: CellType.EMPTY,
            color: undefined,
          };
        }
      }
    }
    
    // Yeni path'i ekle
    path.forEach((pos, index) => {
      if (index === 0 || index === path.length - 1) return; // Start/end cells'i atla
      
      const cell = newGrid.cells[pos.y][pos.x];
      if (cell.type === CellType.EMPTY) {
        console.log('üé® Adding path cell at:', pos.x, pos.y, 'with color:', currentColorRef.current);
        newGrid.cells[pos.y][pos.x] = {
          ...cell,
          type: CellType.PATH,
          color: currentColorRef.current || undefined,
          isConnected: isComplete,
        };
      }
    });
    
    console.log('‚úÖ Grid updated, setting new grid');
    setGrid(newGrid);
  };

  const clearCurrentPath = () => {
    const newGrid = { ...grid };
    newGrid.cells = grid.cells.map((row: Cell[]) => [...row]);
    
    // Ge√ßici path'leri temizle
    for (let y = 0; y < newGrid.dimensions.height; y++) {
      for (let x = 0; x < newGrid.dimensions.width; x++) {
        const cell = newGrid.cells[y][x];
        if (cell.type === CellType.PATH && !cell.isConnected) {
          newGrid.cells[y][x] = {
            ...cell,
            type: CellType.EMPTY,
            color: undefined,
          };
        }
      }
    }
    
    setGrid(newGrid);
  };

  const resetGame = () => {
    const newGrid = createSampleGrid();
    console.log('üîÑ Oyun sƒ±fƒ±rlanƒ±yor, yeni grid:', newGrid);
    setGrid(newGrid);
    setIsDrawing(false);
    setCurrentPath([]);
    setCurrentColor(null);
    setCurrentLetter(null);
    console.log('Oyun sƒ±fƒ±rlandƒ±');
  };

  // Simple Grid render function using createElement
  const renderGrid = () => {
    const cellElements = [];
    
    for (let y = 0; y < grid.dimensions.height; y++) {
      for (let x = 0; x < grid.dimensions.width; x++) {
        const cell = grid.cells[y][x];
        const cellStyle: React.CSSProperties = {
          width: '60px',
          height: '60px',
          border: '2px solid #ddd',
          borderRadius: '8px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          fontSize: '20px',
          fontWeight: 'bold',
          backgroundColor: cell.color || '#f8f9fa',
          color: cell.color ? '#fff' : '#333',
          transition: 'all 0.2s ease',
          position: 'relative',
        };

        // Path cell styling
        if (cell.type === CellType.PATH) {
          cellStyle.backgroundColor = cell.color || '#ddd';
          cellStyle.opacity = cell.isConnected ? 1 : 0.7;
          cellStyle.border = `3px solid ${cell.color || '#999'}`;
        }

        // Visual path styling (ger√ßek zamanlƒ± feedback)
        const isInVisualPath = visualPath.some((p: Position) => p.x === cell.position.x && p.y === cell.position.y);
        if (isInVisualPath && cell.type === CellType.EMPTY) {
          cellStyle.backgroundColor = currentColorRef.current || '#4CAF50';
          cellStyle.border = `3px solid ${currentColorRef.current || '#4CAF50'}`;
          cellStyle.opacity = 0.8;
        }

        // Drawing feedback
        if (isDrawing && cell.type === CellType.EMPTY && !isInVisualPath) {
          cellStyle.backgroundColor = '#e8f5e8';
          cellStyle.border = '2px dashed #4CAF50';
        }

        if (cell.isStart) {
          cellStyle.boxShadow = '0 0 0 4px rgba(255, 255, 255, 0.6)';
        }
        if (cell.isEnd) {
          cellStyle.boxShadow = 'inset 0 0 0 4px rgba(255, 255, 255, 0.8)';
        }

        cellElements.push(
          React.createElement('div', {
            key: cell.id,
            style: cellStyle,
            onClick: (e: React.MouseEvent) => {
              e.preventDefault();
              handleCellClick(cell.position, cell);
            },
            onMouseDown: (e: React.MouseEvent) => {
              e.preventDefault();
              console.log('üéØ MOUSE DOWN!', cell.position);
              handleMouseDown(cell.position, cell);
            },
            onMouseUp: (e: React.MouseEvent) => {
              e.preventDefault();
              console.log('üéØ MOUSE UP!', cell.position);
              handleMouseUp(cell.position, cell);
            },
            onMouseEnter: () => handleCellHover(cell.position, cell),
            onMouseMove: () => {
              if (isMouseDownRef.current && isDrawingRef.current && cell.type === CellType.EMPTY) {
                handleCellHover(cell.position, cell);
              }
            },
            'data-position': `${cell.position.x},${cell.position.y}`,
            'data-type': cell.type,
            'data-letter': cell.letter || '',
          }, cell.letter || (cell.type === CellType.PATH ? '‚óè' : ''))
        );
      }
    }

    return React.createElement('div', {
      style: {
        display: 'grid',
        gridTemplateColumns: `repeat(${grid.dimensions.width}, 60px)`,
        gridTemplateRows: `repeat(${grid.dimensions.height}, 60px)`,
        gap: '4px',
        padding: '20px',
        backgroundColor: '#667eea',
        borderRadius: '16px',
        margin: '20px auto',
        width: 'fit-content',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.2)',
      }
    }, cellElements);
  };

  return React.createElement('div', { style: { padding: '20px', textAlign: 'center' } }, [
    React.createElement('h1', { key: 'title' }, 'üéÆ Flow Puzzle'),
    React.createElement('p', { key: 'desc' }, 'Path √ßizme sistemi aktif! Aynƒ± renkteki harfleri birbirine baƒülayƒ±n.'),
    
    React.createElement('div', { 
      key: 'game-area',
      style: { 
        background: '#f8f9fa', 
        padding: '20px', 
        borderRadius: '12px',
        margin: '20px 0'
      }
    }, [
      React.createElement('h3', { key: 'grid-title' }, 'üéØ Oyun Grid\'i'),
      React.createElement('p', { key: 'grid-desc' }, isDrawing 
        ? `üé® √áizim modu: ${currentLetter} harfi (${currentPath.length} adƒ±m) - Mouse'u ${isMouseDown ? 'basƒ±lƒ± tutun' : 'bƒ±rakƒ±n'}`
        : 'Bir harfe MOUSE DOWN yapƒ±n ve BASILI TUTARAK s√ºr√ºkleyin'),
      React.createElement('button', {
        key: 'reset-btn',
        onClick: resetGame,
        style: {
          backgroundColor: '#ff6b6b',
          color: 'white',
          border: 'none',
          padding: '10px 20px',
          borderRadius: '5px',
          cursor: 'pointer',
          marginBottom: '10px',
          fontSize: '14px'
        }
      }, 'üîÑ Oyunu Sƒ±fƒ±rla'),
      renderGrid()
    ]),
    
    React.createElement('div', { 
      key: 'status',
      style: { 
        background: '#f0f0f0', 
        padding: '15px', 
        borderRadius: '8px',
        margin: '20px 0'
      }
    }, [
      React.createElement('h3', { key: 'status-title' }, 'System Status'),
      React.createElement('p', { key: 'react-status' }, '‚úÖ React.js √ßalƒ±≈üƒ±yor'),
      React.createElement('p', { key: 'grid-status' }, '‚úÖ Grid sistemi aktif'),
      React.createElement('p', { key: 'path-status' }, `‚úÖ Path √ßizme: ${isDrawing ? 'Aktif' : 'Beklemede'}`),
      React.createElement('p', { key: 'api-status' }, apiStatus)
    ])
  ]);
}

export default App;
